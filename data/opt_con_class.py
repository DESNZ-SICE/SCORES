import numpy as np#optimisation high level language, help found at https://www.ima.umn.edu/materials/2017-2018.2/W8.21-25.17/26326/3_PyomoFundamentals.pdf#low level algorithmic solve performed by solverimport pyomo.environ as pyofrom pyomo.opt import SolverFactoryimport timeimport datetime as dtfrom storage import (MultipleStorageAssets)#this class produces an object of the linear program for optimal sizing of the system over the specified timelengthclass System_LinProg_Model:    def __init__(self,surplus,fossilLimit,Mult_Stor,Mult_aggEV,gen_list=[],SimYears=[],YearRange=[]):        '''        == description ==        Initialises the system linear programme        == parameters ==        surplus: (Array<float>) the surplus generation to be smoothed in MW, must be an np array!!        fossilLimit: (float) max acceptable amount of fossil fuel generated energy (MWh)        StorAssets: (mult_stor) or array(<storage>): model can take either as an input, collection of storage devices        gen_list: (array<generation>): list of the potential renewable generators to build        SimYears: (array<int>): list of the years that will be excluded from the optimisation and operated causally        YearRange: (array<int>): [MinYear,MaxYear]        == returns ==        '''                self.surplus = surplus        self.len = len(surplus)        self.fossilLimit = fossilLimit        self.Mult_aggEV = Mult_aggEV        self.gen_list= gen_list        self.SimYears= SimYears        self.YearRange= YearRange                #stor the stor list as a multiple storage asset instead of just a list         if isinstance(Mult_Stor, list):            self.Mult_Stor = MultipleStorageAssets(Mult_Stor)        else:            self.Mult_Stor = Mult_Stor            def Form_Model(self, SizingThenOperation = False):             '''        == description ==        This creates the model object of a linear programme. Useful because Pyomo programmes take a long time to form initially.        Once formed though they can be 'solved' repeatedly whilst only changing specific parameters, this reduces construction time massively.        == parameters ==        SizingThenOperation: (bool): Make this True when the intention is to use the model for repeated system sizing and                                     then operational simulation (using Run_Model_SimOp() method).                == returns ==        '''        self.SizingThenOperation = SizingThenOperation                print('Forming Optimisation Model...')        start = time.time()                  # Create a solver #        opt = pyo.SolverFactory('mosek')            # Create model #        model=pyo.ConcreteModel()  #create the model object, concrete because parameters are known        #model=pyo.AbstractModel()            # Declare Indexs #                model.StorageIndex=range(self.Mult_Stor.n_assets) #Index over the storage assets        model.FleetIndex=range(self.Mult_aggEV.n_assets) #Index over Fleets        model.ChargeType = range(2) #Index over Type of Charger, 0: V2G, 1: Smart, 2: Unmanaged        model.GenIndex = range(len(self.gen_list)) #Index over possible generators                        # Remove Leap Days if Used For Repeated Simulations #               if(self.SizingThenOperation):            #check for full years as input            for g in model.GenIndex:                if(not(len(self.gen_list[g].months)==12)):                    print('To use for system sizing then subsequent operation, must use complete years not months.')                    return            #check that the YearRange Has Been Defined            if(not(len(self.YearRange)==2)):                print('Please Specify the YearRange input to use system sizing then operation.')                return                        if(self.YearRange[1]-self.YearRange[0] <= 0):                print('YearRange[1] must be larger than YearRange[0]')                return                        for y in range(len(self.SimYears)):                if(self.YearRange[0] > self.SimYears[y] or self.YearRange[1] < self.SimYears[y] ):                    print('The specified causally operated years must be within the year range')                    return                        #assign datetimes to the demand and generation inputs            x = dt.timedelta(hours = 1)            N = dt.datetime(self.YearRange[0], 1, 1, hour = 0)                        date_range = []            for t in range(len(self.surplus)):                date_range.append(N)                N=N+x                        #delete the correct values from power_out, demand and date_range!            for t in range(len(self.surplus)-1,-1,-1):                if date_range[t].month == 2 and date_range[t].day == 29:                    date_range.pop(t)                #list                    self.surplus = np.delete(self.surplus,[t]) #np.array                    for g in model.GenIndex:                        self.gen_list[g].power_out.pop(t) #list                                                                                          #then get the new timehorizon, will be 365*24*(YearRange[1]-YearRange[0] - 1)            timehorizon = len(self.surplus) - 365*24                    else: #if not repeatedly reforming the model then no need to delete leap days            timehorizon = len(self.surplus)                               model.TimeIndex=range(timehorizon)  #NB, index for time of day, starts at 0                # Extend EV Connectivity Data if Necessary #        for i in range(0,self.Mult_aggEV.n_assets):                        # Check that the input timeseries are divisible by 24            if not self.Mult_aggEV.assets[i].Nin.size % 24 == 0:                print('Nin/Nout data for fleet ' + self.Mult_aggEV.assets[i].name + ' is not exactly divisible by 24hrs, could lead to unnatural periodicities.')            #increase the length of the in/out plugin series to be longer than the simulation            repeat_num = timehorizon // self.Mult_aggEV.assets[i].Nin.size            self.Mult_aggEV.assets[i].Nin = np.tile(self.Mult_aggEV.assets[i].Nin,repeat_num+1)            repeat_num = timehorizon // self.Mult_aggEV.assets[i].Nout.size            self.Mult_aggEV.assets[i].Nout = np.tile(self.Mult_aggEV.assets[i].Nout,repeat_num+1)                    # Declare decision variables #                #General        model.Pfos=pyo.Var(model.TimeIndex, within = pyo.NonNegativeReals) #power from fossil fuels needed at time t        model.Shed=pyo.Var(model.TimeIndex, within = pyo.NonNegativeReals) #amount of surplus shed                #Storage        model.BuiltCapacity=pyo.Var(model.StorageIndex, within = pyo.NonNegativeReals) #chosen capacity to build of each storage (MWh)        model.C=pyo.Var(model.StorageIndex, model.TimeIndex, within = pyo.NonNegativeReals) #charging rate of each storage asset (MW)        model.D=pyo.Var(model.StorageIndex, model.TimeIndex, within = pyo.NonNegativeReals) #discharging rate of each storage asset (MW)        model.SOC=pyo.Var(model.StorageIndex, model.TimeIndex, within = pyo.NonNegativeReals) #state of charge of the asset at end of timestep t (MWh)                    #EVs        model.EV_TypeBuiltCapacity=pyo.Var(model.FleetIndex, model.ChargeType, within = pyo.NonNegativeReals) #number of built chargers for each type, V2G,Smart,Dumb        model.EV_C=pyo.Var(model.FleetIndex, model.TimeIndex, model.ChargeType, within = pyo.NonNegativeReals) #hourly charging rate of each subset of charger types within each fleet(MW)        model.EV_D=pyo.Var(model.FleetIndex, model.TimeIndex, model.ChargeType, within = pyo.NonNegativeReals) #hourly discharging rate of each subset of charger types within each fleet(MW)        model.EV_SOC=pyo.Var(model.FleetIndex, model.TimeIndex, model.ChargeType, within = pyo.NonNegativeReals) #state of charge of the asset at end of timestep t (MWh)                    #Generators        model.GenCapacity = pyo.Var(model.GenIndex,within = pyo.NonNegativeReals) #the built capacity (MW) of each generator type                         # Declare Parameters #                #Parameters save time on setting up the model for repeated runs, as they can be adjusted without having to rebuild the entire model        #Declaring Parameters is fiddly, needs to be done with an enumerated dictionary of tuples as below                #if I am running repeated simulations, then don't initialize parameters        if(self.SizingThenOperation):            model.Demand = pyo.Param(model.TimeIndex, within = pyo.Reals, mutable = True)                model.NormalisedGen = pyo.Param(model.GenIndex, model.TimeIndex, within = pyo.NonNegativeReals, mutable = True)        else:                            model.Demand = pyo.Param(model.TimeIndex, initialize = dict(enumerate(self.surplus)), within = pyo.Reals, mutable = True)                                ref = {} #this gives the normalised power output of generator g at time t (multiplied by the built capacity to give the MW)            for g in model.GenIndex:                for t in model.TimeIndex:                    ref[g,model.TimeIndex[t]] = self.gen_list[g].power_out[t]/max(self.gen_list[g].power_out)            model.NormalisedGen = pyo.Param(model.GenIndex, model.TimeIndex, within = pyo.NonNegativeReals, initialize = ref)                        N = np.empty([self.Mult_aggEV.n_assets,timehorizon]) #the normalised number of EVs connected at a given time (EV connections/disconnections are assumed to occur at teh start of the timestep)        for k in range(self.Mult_aggEV.n_assets):            for t in range(timehorizon):                if t == 0:                    N[k,t] = self.Mult_aggEV.assets[k].initial_number                else:                    N[k,t] = N[k,t-1] + self.Mult_aggEV.assets[k].Nin[t] - self.Mult_aggEV.assets[k].Nout[t]                    # Declare constraints #                #General Constraints        #Power Balance        model.PowerBalance = pyo.ConstraintList()        for t in range(timehorizon):                                                    #this is a normalised power output between 0-1            #model.PowerBalance.add(surplus[t] + sum(model.GenCapacity[g]*(gen_list[g].power_out[t]/max(gen_list[g].power_out)) for g in model.GenIndex)- model.Shed[t] + sum(model.D[i,t] * Mult_Stor.assets[i].eff_out/100.0 - model.C[i,t] * 100.0/Mult_Stor.assets[i].eff_in for i in model.StorageIndex) + model.Pfos[t] +  sum(model.EV_D[k,t,0] * Mult_aggEV.assets[k].eff_out/100  - sum( model.EV_C[k,t,b] * 100/Mult_aggEV.assets[k].eff_in for b in model.ChargeType)  for k in model.FleetIndex)== 0)            model.PowerBalance.add(model.Demand[t] + sum(model.GenCapacity[g]*model.NormalisedGen[g,t] for g in model.GenIndex)- model.Shed[t] + sum(model.D[i,t] * self.Mult_Stor.assets[i].eff_out/100.0 - model.C[i,t] * 100.0/self.Mult_Stor.assets[i].eff_in for i in model.StorageIndex) + model.Pfos[t] +  sum(model.EV_D[k,t,0] * self.Mult_aggEV.assets[k].eff_out/100  - sum( model.EV_C[k,t,b] * 100/self.Mult_aggEV.assets[k].eff_in for b in model.ChargeType)  for k in model.FleetIndex)== 0)                    #Specified Amount of Fossil Fuel Input        model.FossilLimit = pyo.ConstraintList()        model.FossilLimit.add(sum(model.Pfos[t] for t in model.TimeIndex) <= self.fossilLimit)            #Generator Constraints        model.genlimits = pyo.ConstraintList()        for g in model.GenIndex:            if(len(self.gen_list[g].limits)>0):                model.genlimits.add(model.GenCapacity[g] >= self.gen_list[g].limits[0])                model.genlimits.add(model.GenCapacity[g] <= self.gen_list[g].limits[1])            #Storage Constraints        model.maxSOC = pyo.ConstraintList()        model.battery_charge_level = pyo.ConstraintList()        model.maxD = pyo.ConstraintList()        model.maxC = pyo.ConstraintList()        model.storagelimits = pyo.ConstraintList()        for i in range(self.Mult_Stor.n_assets):            if(len(self.Mult_Stor.assets[i].limits)>0):                model.storagelimits.add(model.BuiltCapacity[i] >=  self.Mult_Stor.assets[i].limits[0])                model.storagelimits.add(model.BuiltCapacity[i] <=  self.Mult_Stor.assets[i].limits[1])                            for t in range(timehorizon):                model.maxSOC.add(model.SOC[i,t] <= model.BuiltCapacity[i]) #SOC less than maximum                model.maxD.add(model.D[i,t] * self.Mult_Stor.assets[i].eff_out/100.0 <= model.BuiltCapacity[i] * self.Mult_Stor.assets[i].max_d_rate/100)                model.maxC.add(model.C[i,t] * 100.0/self.Mult_Stor.assets[i].eff_in <= model.BuiltCapacity[i] * self.Mult_Stor.assets[i].max_c_rate/100)                               if t == 0:                    model.battery_charge_level.add(model.SOC[i,t]== 0.5*model.BuiltCapacity[i] + model.C[i,t] - model.D[i,t]) #batteries all start at half charge                else:                    model.battery_charge_level.add(model.SOC[i,t]== model.SOC[i,t-1]*(1-(self.Mult_Stor.assets[i].self_dis/(100*30*24))) + model.C[i,t] - model.D[i,t])                            #EV Constraints        model.EV_maxSOC = pyo.ConstraintList()        model.EV_minSOC = pyo.ConstraintList()        model.EV_battery_charge_level = pyo.ConstraintList()        model.EV_maxD = pyo.ConstraintList()        model.EV_maxC = pyo.ConstraintList()        model.Built_Asset_Sum = pyo.ConstraintList()        model.ChargerTypeLimits = pyo.ConstraintList() #allows the user to specify the max number of a certain charger type                for k in range(self.Mult_aggEV.n_assets):            #constraint to make sure all the different built capacities add to one            model.Built_Asset_Sum.add(sum(model.EV_TypeBuiltCapacity[k,b] for b in model.ChargeType) == self.Mult_aggEV.assets[k].number)                        for b in model.ChargeType:                if (len(self.Mult_aggEV.assets[k].limits) > 0):                    model.ChargerTypeLimits.add(model.EV_TypeBuiltCapacity[k,b] >= self.Mult_aggEV.assets[k].limits[2*b])                    model.ChargerTypeLimits.add(model.EV_TypeBuiltCapacity[k,b] <= self.Mult_aggEV.assets[k].limits[2*b+1])                                    for t in range(timehorizon):                    model.EV_maxSOC.add(model.EV_SOC[k,t,b] <= model.EV_TypeBuiltCapacity[k,b]*N[k,t]*self.Mult_aggEV.assets[k].max_SOC/1000) #constraint to limit the max SOC                    model.EV_minSOC.add(model.EV_SOC[k,t,b] >= model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nout[t]*self.Mult_aggEV.assets[k].Eout/1000 - model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nin[t]*self.Mult_aggEV.assets[k].Ein/1000) #constraint to make sure that there is always enough charge for the EVs to plug out                    model.EV_maxC.add(model.EV_C[k,t,b] * 100/self.Mult_aggEV.assets[k].eff_in <= model.EV_TypeBuiltCapacity[k,b]*N[k,t]*self.Mult_aggEV.assets[k].max_c_rate/1000)                                        if(b==0):                        #V2G specific Constraints                        model.EV_maxD.add(model.EV_D[k,t,b] * self.Mult_aggEV.assets[k].eff_out/100 <= model.EV_TypeBuiltCapacity[k,b]*N[k,t]*self.Mult_aggEV.assets[k].max_d_rate/1000)                                                if t == 0:                            model.EV_battery_charge_level.add(model.EV_SOC[k,t,b] == 0.5 * model.EV_TypeBuiltCapacity[k,b]*N[k,t]*self.Mult_aggEV.assets[k].max_SOC/1000 + model.EV_C[k,t,b] - model.EV_D[k,t,b] - model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nout[t]*self.Mult_aggEV.assets[k].Eout/1000 + model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nin[t]*self.Mult_aggEV.assets[k].Ein/1000)                         else:                            model.EV_battery_charge_level.add(model.EV_SOC[k,t,b] == model.EV_SOC[k,t-1,b] + model.EV_C[k,t,b] - model.EV_D[k,t,b] - model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nout[t]*self.Mult_aggEV.assets[k].Eout/1000 + model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nin[t]*self.Mult_aggEV.assets[k].Ein/1000)                     elif b==1:                        #Smart Unidirectional                        if t == 0:                            model.EV_battery_charge_level.add(model.EV_SOC[k,t,b] == 0.5 * model.EV_TypeBuiltCapacity[k,b]*N[k,t]*self.Mult_aggEV.assets[k].max_SOC/1000 + model.EV_C[k,t,b] - model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nout[t]*self.Mult_aggEV.assets[k].Eout/1000 + model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nin[t]*self.Mult_aggEV.assets[k].Ein/1000)                         else:                            model.EV_battery_charge_level.add(model.EV_SOC[k,t,b] == model.EV_SOC[k,t-1,b] + model.EV_C[k,t,b] - model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nout[t]*self.Mult_aggEV.assets[k].Eout/1000 + model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nin[t]*self.Mult_aggEV.assets[k].Ein/1000)     # Declare objective function #        model.obj=pyo.Objective(                                                                                                            #adding this small 0.05 stops the model from charging and discharging simultaneously unecessarily                                                                                                                                      this penalises fossil fuel use to encourage healthier charging behaviour        expr=sum((timehorizon/(365*24))*model.GenCapacity[g]*self.gen_list[g].fixed_cost + model.GenCapacity[g]*self.gen_list[g].variable_cost*sum(self.gen_list[g].power_out[t]/max(self.gen_list[g].power_out) for t in model.TimeIndex) for g in model.GenIndex) + sum((timehorizon/(365*24))*self.Mult_Stor.assets[i].fixed_cost * model.BuiltCapacity[i] for i in model.StorageIndex) + sum( sum((self.Mult_Stor.assets[i].variable_cost+0.05) * model.D[i,t] for t in model.TimeIndex) for i in model.StorageIndex) + sum(sum((timehorizon/(365*24)) * self.Mult_aggEV.assets[k].chargercost[b] * model.EV_TypeBuiltCapacity[k,b] for b in model.ChargeType)for k in model.FleetIndex) + sum(model.Pfos[t] for t in model.TimeIndex) + sum( sum((0.05) * model.EV_D[k,t,0] for t in model.TimeIndex) for k in model.FleetIndex),           sense=pyo.minimize)                self.model = model                end = time.time()        print('Model Formation Complete after: ',int(end - start), 's')