import numpy as np#optimisation high level language, help found at https://www.ima.umn.edu/materials/2017-2018.2/W8.21-25.17/26326/3_PyomoFundamentals.pdf#low level algorithmic solve performed by solverimport pyomo.environ as pyofrom pyomo.opt import SolverFactoryimport timeimport datetime as dtfrom storage import (MultipleStorageAssets)from aggregatedEVs import MultipleAggregatedEVsfrom pandas import DataFramedef opt_results_to_df(model):        '''        == description ==        Takes a solved model and outputs the results of its most recent solve as 2 data frames, one summarising the outputs, the other detailing operation!        == parameters ==        model: (pyo.ConcreteModel()) This is a pyomo model that has been constructed then solved. The solved parameter values can be extracted from it.                == returns ==        '''                df1 = DataFrame({'Total Demand (GWh)': [int(sum(-pyo.value(model.Demand[t]) for t in model.TimeIndex)/1000.0)], 'Total Fossil Fuel (GWh)': [int(sum(pyo.value(model.Pfos[t]) for t in model.TimeIndex)/1000.0)],'Total Curtailement (GWh)': [int(sum(pyo.value(model.Shed[t]) for t in model.TimeIndex)/1000.0)]})            #Need to Work out how to get the price as an output (could do with changing the costs to model parameters instead)        for g in model.GenIndex:                df1['Gen '+str(g) + ' Cap (GW)'] = int(pyo.value(model.GenCapacity[g])/10.0)/100.0                for i in model.StorageIndex:                df1['Stor '+str(i) + ' Cap (GWh)'] = int(pyo.value(model.BuiltCapacity[i])/10.0)/100.0                for k in model.FleetIndex:            for b in model.ChargeType:                if b == 0:                    df1['Fleet '+str(k) + ' V2G'] = int(pyo.value(model.EV_TypeBuiltCapacity[k,b]))                elif b ==1:                    df1['Fleet '+str(k) + ' Uni'] = int(pyo.value(model.EV_TypeBuiltCapacity[k,b]))                return df1  def store_optimisation_results(model, Mult_aggEV):        '''        == description ==        #stores the results of a sizing optimisation in the generator, EV and Storage objects. Useful for plotting and keeping a record          == parameters ==        model: (pyo.ConcreteModel()) This is a pyomo model that has been constructed then solved. The solved parameter values can be extracted from it.        Mult_aggEV: The mutliple aggregated fleet object that has been optimised                == returns ==        '''        timehorizon = max(model.TimeIndex) + 1    #Agg EV Fleets        EV_SOC_results = np.empty([Mult_aggEV.n_assets,timehorizon+1,2])        EV_D_results = np.empty([Mult_aggEV.n_assets,timehorizon]) #as only V2G has discharge variable        EV_C_results = np.empty([Mult_aggEV.n_assets,timehorizon,2])                for k in range(Mult_aggEV.n_assets):            Mult_aggEV.assets[k].reset()                        for b in range(2):                Mult_aggEV.assets[k].chargertype[b] = pyo.value(model.EV_TypeBuiltCapacity[k,b])/Mult_aggEV.assets[k].number                EV_SOC_results[k,0,b] = 0.5 * pyo.value(model.EV_TypeBuiltCapacity[k,b])*Mult_aggEV.assets[k].N[0]*Mult_aggEV.assets[k].max_SOC/1000                                for t in range(0,timehorizon):                    EV_SOC_results[k,t+1,b] = pyo.value(model.EV_SOC[k,t,b])                    EV_C_results[k,t,b] = pyo.value(model.EV_C[k,t,b])                                        if(b==0):                        EV_D_results[k,t] = pyo.value(model.EV_D[k,t,b])                                                                   Mult_aggEV.assets[k].discharge = EV_D_results[k,:]            Mult_aggEV.assets[k].charge = EV_C_results[k,:,:]            Mult_aggEV.assets[k].SOC = EV_SOC_results[k,:,:]                    for k in range(Mult_aggEV.n_assets):            for b in range(2):                                if(b==0):                    Mult_aggEV.assets[k].V2G_en_in = sum(EV_C_results[k,:,b]*100/Mult_aggEV.assets[k].eff_in)                    Mult_aggEV.assets[k].V2G_en_out = sum(EV_D_results[k,:]*Mult_aggEV.assets[k].eff_out/100)                elif(b==1):                    Mult_aggEV.assets[k].Smart_en_in = sum(EV_C_results[k,:,b]*100/Mult_aggEV.assets[k].eff_in)                   #this class produces an object of the linear program for optimal sizing of the system over the specified timelengthclass System_LinProg_Model:    def __init__(self,surplus,fossilLimit,Mult_Stor=[],Mult_aggEV=[],gen_list=[],YearRange=[]):        '''        == description ==        Initialises the system linear programme        == parameters ==        surplus: (Array<float>) the surplus generation to be smoothed in MW, must be an np array!! (can just be demand also (demand should be -ve))        fossilLimit: (float) fraction of demand (i.e. -ve surplus) that can come from fossil fuels (expected values between 0:0.05....)        StorAssets: (mult_stor) or array(<storage>): model can take either as an input, collection of storage devices        gen_list: (array<generation>): list of the potential renewable generators to build        YearRange: (array<int>): [MinYear,MaxYear]        fossilfuelpenalty: (float): cost using fossil fuels (£/MWh). For most operations this is irrelevant as the fossil fuel energy is limited to a max via fossilLimit, but it may be desired to increase the cost         == returns ==        '''                self.surplus = surplus        self.fossilLimit = fossilLimit        self.gen_list= gen_list        self.YearRange= YearRange                self.df_capital = DataFrame() #this will contain the built capacities post optimisation run                #stor the stor list as a multiple storage asset instead of just a list         if isinstance(Mult_Stor, list):            self.Mult_Stor = MultipleStorageAssets(Mult_Stor)        else:            self.Mult_Stor = Mult_Stor                    if isinstance(Mult_aggEV, list):            self.Mult_aggEV = MultipleAggregatedEVs(Mult_aggEV)        else:            self.Mult_aggEV = Mult_aggEV            def Form_Model(self, SizingThenOperation = False, fossilfuelpenalty = 1.0):             '''        == description ==        This creates the model object of a linear programme. Useful because Pyomo programmes take a long time to form initially.        Once formed though they can be 'solved' repeatedly whilst only changing specific parameters, this reduces construction time massively.        == parameters ==        SizingThenOperation: (bool): Make this True when the intention is to use the model for repeated system sizing and                                     then operational simulation (using Run_Model_SimOp() method). This means that the timehorizon                                     will be one year less than the year range states and that the leap years will be removed.        fossilfuelpenalty: (float): cost using fossil fuels during the non-causal simulation (£/MWh).                == returns ==        '''        self.SizingThenOperation = SizingThenOperation                print('Forming Optimisation Model...')        start = time.time()            # Create model #        model=pyo.ConcreteModel()  #create the model object, concrete because parameters are known        #model=pyo.AbstractModel()            # Declare Indexs #                model.StorageIndex=range(self.Mult_Stor.n_assets) #Index over the storage assets        model.FleetIndex=range(self.Mult_aggEV.n_assets) #Index over Fleets        model.ChargeType = range(2) #Index over Type of Charger, 0: V2G, 1: Smart, 2: Unmanaged        model.GenIndex = range(len(self.gen_list)) #Index over possible generators                        # Remove Leap Days if Used For Repeated Simulations #               if(self.SizingThenOperation):            #check for full years as input            for g in model.GenIndex:                if(not(len(self.gen_list[g].months)==12)):                    print('To use for system sizing then subsequent operation, must use complete years not months.')                    return            #check that the YearRange Has Been Defined            if(not(len(self.YearRange)==2)):                print('Please Specify the YearRange input to use system sizing then operation.')                return                        if(self.YearRange[1]-self.YearRange[0] <= 0):                print('YearRange[1] must be larger than YearRange[0]')                return                        #assign datetimes to the demand and generation inputs            x = dt.timedelta(hours = 1)            N1 = dt.datetime(self.YearRange[0], 1, 1, hour = 0)                        date_range = []            for t in range(len(self.surplus)):                date_range.append(N1)                N1=N1+x                        #delete the correct values from power_out, demand and date_range!            for t in range(len(self.surplus)-1,-1,-1):                if date_range[t].month == 2 and date_range[t].day == 29:                    date_range.pop(t)                #list                    self.surplus = np.delete(self.surplus,[t]) #np.array                    for g in model.GenIndex:                        self.gen_list[g].power_out.pop(t) #list                                                                                          #then get the new timehorizon, will be 365*24*(YearRange[1]-YearRange[0] - 1)            timehorizon = len(self.surplus) - 365*24                    else: #if not repeatedly reforming the model then no need to delete leap days            timehorizon = len(self.surplus)                               model.TimeIndex=range(timehorizon)  #NB, index for time of day, starts at 0                # Extend EV Connectivity Data if Necessary #        for i in range(0,self.Mult_aggEV.n_assets):                        # Check that the input timeseries are divisible by 24            if not self.Mult_aggEV.assets[i].Nin.size % 24 == 0:                print('Nin/Nout data for fleet ' + self.Mult_aggEV.assets[i].name + ' is not exactly divisible by 24hrs, could lead to unnatural periodicities.')            #increase the length of the in/out plugin series to be longer than the simulation            repeat_num = timehorizon // self.Mult_aggEV.assets[i].Nin.size            self.Mult_aggEV.assets[i].Nin = np.tile(self.Mult_aggEV.assets[i].Nin,repeat_num+1)            repeat_num = timehorizon // self.Mult_aggEV.assets[i].Nout.size            self.Mult_aggEV.assets[i].Nout = np.tile(self.Mult_aggEV.assets[i].Nout,repeat_num+1)                    # Declare decision variables #                #General        model.Pfos=pyo.Var(model.TimeIndex, within = pyo.NonNegativeReals) #power from fossil fuels needed at time t        model.Shed=pyo.Var(model.TimeIndex, within = pyo.NonNegativeReals) #amount of surplus shed                #Storage        model.BuiltCapacity=pyo.Var(model.StorageIndex, within = pyo.NonNegativeReals) #chosen capacity to build of each storage (MWh)        model.C=pyo.Var(model.StorageIndex, model.TimeIndex, within = pyo.NonNegativeReals) #charging rate of each storage asset (MW) (from battery side, so energy into battety)        model.D=pyo.Var(model.StorageIndex, model.TimeIndex, within = pyo.NonNegativeReals) #discharging rate of each storage asset (MW) (from battery side, so energy out of battery, this will be larger than than the energy into the grid)        model.SOC=pyo.Var(model.StorageIndex, model.TimeIndex, within = pyo.NonNegativeReals) #state of charge of the asset at end of timestep t (MWh)                    #EVs        model.EV_TypeBuiltCapacity=pyo.Var(model.FleetIndex, model.ChargeType, within = pyo.NonNegativeReals) #number of built chargers for each type, V2G,Smart,Dumb        model.EV_C=pyo.Var(model.FleetIndex, model.TimeIndex, model.ChargeType, within = pyo.NonNegativeReals) #hourly charging rate of each subset of charger types within each fleet(MW) (battery side, so energy into batteries)        model.EV_D=pyo.Var(model.FleetIndex, model.TimeIndex, model.ChargeType, within = pyo.NonNegativeReals) #hourly discharging rate of each subset of charger types within each fleet(MW) (battery side, so energy out of battery)        model.EV_SOC=pyo.Var(model.FleetIndex, model.TimeIndex, model.ChargeType, within = pyo.NonNegativeReals) #state of charge of the asset at end of timestep t (MWh)                    #Generators        model.GenCapacity = pyo.Var(model.GenIndex,within = pyo.NonNegativeReals) #the built capacity (MW) of each generator type                         # Declare Parameters #                #Parameters save time on setting up the model for repeated runs, as they can be adjusted without having to rebuild the entire model        #Declaring Parameters is fiddly, needs to be done with an enumerated dictionary of tuples as below                #if I am running repeated simulations, then don't initialize parameters        if(self.SizingThenOperation):            model.Demand = pyo.Param(model.TimeIndex, within = pyo.Reals, mutable = True)                model.NormalisedGen = pyo.Param(model.GenIndex, model.TimeIndex, within = pyo.NonNegativeReals, mutable = True)        else:                            model.Demand = pyo.Param(model.TimeIndex, initialize = dict(enumerate(self.surplus)), within = pyo.Reals, mutable = True)                                ref = {} #this gives the normalised power output of generator g at time t (multiplied by the built capacity to give the MW)            for g in model.GenIndex:                for t in model.TimeIndex:                    ref[g,model.TimeIndex[t]] = self.gen_list[g].power_out[t]/max(self.gen_list[g].power_out)            model.NormalisedGen = pyo.Param(model.GenIndex, model.TimeIndex, within = pyo.NonNegativeReals, initialize = ref)                #the limit on energy from fossil fuels is specified as a % of the -ve given surplus (i.e. demand),         #this can be updated for repeated sims or not!        limit = -self.fossilLimit * sum(self.surplus * (self.surplus < 0))        model.foss_lim_param = pyo.Param(within = pyo.NonNegativeReals,mutable = True,initialize = limit)                N = np.empty([self.Mult_aggEV.n_assets,timehorizon]) #the normalised number of EVs connected at a given time (EV connections/disconnections are assumed to occur at teh start of the timestep)        for k in range(self.Mult_aggEV.n_assets):            for t in range(timehorizon):                if t == 0:                    N[k,t] = self.Mult_aggEV.assets[k].initial_number                else:                    N[k,t] = N[k,t-1] + self.Mult_aggEV.assets[k].Nin[t] - self.Mult_aggEV.assets[k].Nout[t]                                            self.Mult_aggEV.assets[k].N = N[k,:]                    # Declare constraints #                #General Constraints        #Power Balance        model.PowerBalance = pyo.ConstraintList()        for t in range(timehorizon):                                                    #this is a normalised power output between 0-1            #model.PowerBalance.add(surplus[t] + sum(model.GenCapacity[g]*(gen_list[g].power_out[t]/max(gen_list[g].power_out)) for g in model.GenIndex)- model.Shed[t] + sum(model.D[i,t] * Mult_Stor.assets[i].eff_out/100.0 - model.C[i,t] * 100.0/Mult_Stor.assets[i].eff_in for i in model.StorageIndex) + model.Pfos[t] +  sum(model.EV_D[k,t,0] * Mult_aggEV.assets[k].eff_out/100  - sum( model.EV_C[k,t,b] * 100/Mult_aggEV.assets[k].eff_in for b in model.ChargeType)  for k in model.FleetIndex)== 0)            model.PowerBalance.add(model.Demand[t] + sum(model.GenCapacity[g]*model.NormalisedGen[g,t] for g in model.GenIndex)- model.Shed[t] + sum(model.D[i,t] * self.Mult_Stor.assets[i].eff_out/100.0 - model.C[i,t] * 100.0/self.Mult_Stor.assets[i].eff_in for i in model.StorageIndex) + model.Pfos[t] +  sum(model.EV_D[k,t,0] * self.Mult_aggEV.assets[k].eff_out/100  - sum( model.EV_C[k,t,b] * 100/self.Mult_aggEV.assets[k].eff_in for b in model.ChargeType)  for k in model.FleetIndex)== 0)                    #Specified Amount of Fossil Fuel Input        model.FossilLimit = pyo.ConstraintList()        model.FossilLimit.add(sum(model.Pfos[t] for t in model.TimeIndex) <= model.foss_lim_param)                    #Generator Constraints        model.genlimits = pyo.ConstraintList()        for g in model.GenIndex:            if(len(self.gen_list[g].limits)>0):                model.genlimits.add(model.GenCapacity[g] >= self.gen_list[g].limits[0])                model.genlimits.add(model.GenCapacity[g] <= self.gen_list[g].limits[1])            #Storage Constraints        model.maxSOC = pyo.ConstraintList()        model.battery_charge_level = pyo.ConstraintList()        model.maxD = pyo.ConstraintList()        model.maxC = pyo.ConstraintList()        model.storagelimits = pyo.ConstraintList()        for i in range(self.Mult_Stor.n_assets):            if(len(self.Mult_Stor.assets[i].limits)>0):                model.storagelimits.add(model.BuiltCapacity[i] >=  self.Mult_Stor.assets[i].limits[0])                model.storagelimits.add(model.BuiltCapacity[i] <=  self.Mult_Stor.assets[i].limits[1])                            for t in range(timehorizon):                model.maxSOC.add(model.SOC[i,t] <= model.BuiltCapacity[i]) #SOC less than maximum                model.maxD.add(model.D[i,t] * self.Mult_Stor.assets[i].eff_out/100.0 <= model.BuiltCapacity[i] * self.Mult_Stor.assets[i].max_d_rate/100)                model.maxC.add(model.C[i,t] * 100.0/self.Mult_Stor.assets[i].eff_in <= model.BuiltCapacity[i] * self.Mult_Stor.assets[i].max_c_rate/100)                               if t == 0:                    model.battery_charge_level.add(model.SOC[i,t]== 0.5*model.BuiltCapacity[i] + model.C[i,t] - model.D[i,t]) #batteries all start at half charge                else:                    model.battery_charge_level.add(model.SOC[i,t]== model.SOC[i,t-1]*(1-(self.Mult_Stor.assets[i].self_dis/(100*30*24))) + model.C[i,t] - model.D[i,t])                            #EV Constraints        model.EV_maxSOC = pyo.ConstraintList()        model.EV_minSOC = pyo.ConstraintList()        model.EV_battery_charge_level = pyo.ConstraintList()        model.EV_maxD = pyo.ConstraintList()        model.EV_maxC = pyo.ConstraintList()        model.Built_Asset_Sum = pyo.ConstraintList()        model.ChargerTypeLimits = pyo.ConstraintList() #allows the user to specify the max number of a certain charger type                for k in range(self.Mult_aggEV.n_assets):            #constraint to make sure all the different built capacities add to one            model.Built_Asset_Sum.add(sum(model.EV_TypeBuiltCapacity[k,b] for b in model.ChargeType) == self.Mult_aggEV.assets[k].number)                        for b in model.ChargeType:                if (len(self.Mult_aggEV.assets[k].limits) > 0):                    model.ChargerTypeLimits.add(model.EV_TypeBuiltCapacity[k,b] >= self.Mult_aggEV.assets[k].limits[2*b])                    model.ChargerTypeLimits.add(model.EV_TypeBuiltCapacity[k,b] <= self.Mult_aggEV.assets[k].limits[2*b+1])                                    for t in range(timehorizon):                    model.EV_maxSOC.add(model.EV_SOC[k,t,b] <= model.EV_TypeBuiltCapacity[k,b]*N[k,t]*self.Mult_aggEV.assets[k].max_SOC/1000) #constraint to limit the max SOC                    model.EV_minSOC.add(model.EV_SOC[k,t,b] >= model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nout[t]*self.Mult_aggEV.assets[k].Eout/1000) #constraint to make sure that there is always enough charge for the EVs to plug out                    model.EV_maxC.add(model.EV_C[k,t,b] * 100/self.Mult_aggEV.assets[k].eff_in <= model.EV_TypeBuiltCapacity[k,b]*N[k,t]*self.Mult_aggEV.assets[k].max_c_rate/1000)                                        if(b==0):                        #V2G specific Constraints                        model.EV_maxD.add(model.EV_D[k,t,b] * self.Mult_aggEV.assets[k].eff_out/100 <= model.EV_TypeBuiltCapacity[k,b]*N[k,t]*self.Mult_aggEV.assets[k].max_d_rate/1000)                                                if t == 0:                            model.EV_battery_charge_level.add(model.EV_SOC[k,t,b] == 0.5 * model.EV_TypeBuiltCapacity[k,b]*N[k,t]*self.Mult_aggEV.assets[k].max_SOC/1000 + model.EV_C[k,t,b] - model.EV_D[k,t,b] - model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nout[t]*self.Mult_aggEV.assets[k].Eout/1000 + model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nin[t]*self.Mult_aggEV.assets[k].Ein/1000)                         else:                            model.EV_battery_charge_level.add(model.EV_SOC[k,t,b] == model.EV_SOC[k,t-1,b] + model.EV_C[k,t,b] - model.EV_D[k,t,b] - model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nout[t]*self.Mult_aggEV.assets[k].Eout/1000 + model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nin[t]*self.Mult_aggEV.assets[k].Ein/1000)                     elif b==1:                        #Smart Unidirectional                        if t == 0:                            model.EV_battery_charge_level.add(model.EV_SOC[k,t,b] == 0.5 * model.EV_TypeBuiltCapacity[k,b]*N[k,t]*self.Mult_aggEV.assets[k].max_SOC/1000 + model.EV_C[k,t,b] - model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nout[t]*self.Mult_aggEV.assets[k].Eout/1000 + model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nin[t]*self.Mult_aggEV.assets[k].Ein/1000)                         else:                            model.EV_battery_charge_level.add(model.EV_SOC[k,t,b] == model.EV_SOC[k,t-1,b] + model.EV_C[k,t,b] - model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nout[t]*self.Mult_aggEV.assets[k].Eout/1000 + model.EV_TypeBuiltCapacity[k,b]*self.Mult_aggEV.assets[k].Nin[t]*self.Mult_aggEV.assets[k].Ein/1000)     # Declare objective function #        model.obj=pyo.Objective(                                                                                                            #adding this small 0.05 stops the model from charging and discharging simultaneously unecessarily                                                                                                                                      this penalises fossil fuel use to encourage healthier charging behaviour        expr=sum((timehorizon/(365*24))*model.GenCapacity[g]*self.gen_list[g].fixed_cost + model.GenCapacity[g]*self.gen_list[g].variable_cost*sum(self.gen_list[g].power_out[t]/max(self.gen_list[g].power_out) for t in model.TimeIndex) for g in model.GenIndex) + sum((timehorizon/(365*24))*self.Mult_Stor.assets[i].fixed_cost * model.BuiltCapacity[i] for i in model.StorageIndex) + sum( sum((self.Mult_Stor.assets[i].variable_cost+0.05) * model.D[i,t] for t in model.TimeIndex) for i in model.StorageIndex) + sum(sum((timehorizon/(365*24)) * self.Mult_aggEV.assets[k].chargercost[b] * model.EV_TypeBuiltCapacity[k,b] for b in model.ChargeType)for k in model.FleetIndex) + sum(fossilfuelpenalty * model.Pfos[t] for t in model.TimeIndex) + sum( sum((0.05) * model.EV_D[k,t,0] for t in model.TimeIndex) for k in model.FleetIndex),           sense=pyo.minimize)                self.model = model                end = time.time()        print('Model Formation Complete after: ',int(end - start), 's')    def Run_Sizing(self):        '''        == description ==        Solve the linear programme specified by Form_Model. Results recorded by updating df_capital                == parameters ==                              == returns ==                '''        if self.SizingThenOperation:            print('Sizing  Requires Model Constructed with SizingThenOperation = False')            return                    # Create a solver #        opt = pyo.SolverFactory('mosek')            # Solve #        print('Finding Optimal System ...')        start = time.time()                opt.solve(self.model)                  end = time.time()        print('Solved after: ',int(end - start),'s')            # Update System Characteristics #                    self.df_capital = opt_results_to_df(self.model)        store_optimisation_results(self.model,self.Mult_aggEV)                    def Run_Sizing_Then_Op(self,SimYears,c_order=[],d_order=[], V2G_discharge_threshold = 0.0):        '''        == description ==        Runs repeated simulations, excluding the years Mentioned in SimYears                == parameters ==        SimYears: (array<int>): list of the years that will be excluded from the optimisation and operated causally        c_order/d_order: The charge/discharge order during the causal system operation. Bare in mind, the order of 'storage' during operation corresponding to the index in c_order/d_order is: [MultStor.assets[0],MultStor.assets[1]...,V2G Mult_aggEV.assets[0],unidirectional Mult_aggEV.assets[0],V2G Mult_aggEV.assets[1]...  ]                        Remember, need two entries for every fleet because the V2G and Smart virtual batteries are distinct.         V2G_discharge_threshold: (float), the SOC threshold (KWh) of the EV batteries, below which V2G will not discharge during causal system operation                       == returns ==        df: (DataFrame): this contains the reliability of the causal sim runs and the % of EV driving energy met by renewables!                '''        self.SimYears= SimYears                if len(c_order) == 0:            c_order = range(self.Mult_Stor.n_assets + 2 * self.Mult_aggEV.n_assets)                if len(d_order) == 0:            d_order = range(self.Mult_Stor.n_assets + 2 * self.Mult_aggEV.n_assets)            # Create a solver #        opt = pyo.SolverFactory('mosek')                if not(self.SizingThenOperation):            print('Sizing then Op Requires Model Constructed with SizingThenOperation = True')            return                for y in range(len(self.SimYears)):            if(self.YearRange[0] > self.SimYears[y] or self.YearRange[1] < self.SimYears[y] ):                print('The specified causally operated years must be within the year range')                return    # Create Output Recording objects #                Causal_Reliability = [] #The % of demand met by renewable power        Causal_EV_Reliability = [] #The % of driving Energy Provided by Renewable energy (if no chargers of a certain type this is set to 100%)        for x in range(2*self.Mult_aggEV.n_assets):            Causal_EV_Reliability.append([])                    Non_Causal_Reliability = [] #The % of demand met by renewable power                            # Run Simulation #        if(len(SimYears) > 0):            for y in range(len(SimYears)):                                #these value are uses within the sizing operation ot find the ideal system                surplus_instance=np.zeros([365*24*(self.YearRange[1]-self.YearRange[0])])                gen_power_instance = np.zeros([len(self.gen_list),365*24*(self.YearRange[1]-self.YearRange[0])])                                #these values are for simulating the operation of the previously sized system                surplus_simulation = np.zeros([365*24])                gen_power_simulation = np.zeros([len(self.gen_list),365*24])                                #remove simulation year from the parameter input data                years_encompassed = range(self.YearRange[0],self.YearRange[1]+1)                 counter = 0                for x in range(self.YearRange[1]+1-self.YearRange[0]):                    if(not(years_encompassed[x] ==SimYears[y])):                        surplus_instance[counter*365*24:(counter+1)*365*24] = self.surplus[x*365*24:(x+1)*365*24]                        for g in self.model.GenIndex:                            gen_power_instance[g,counter*365*24:(counter+1)*365*24] = np.asarray(self.gen_list[g].power_out[x*365*24:(x+1)*365*24])/max(self.gen_list[g].power_out)                                                    counter = counter + 1                    else:                        surplus_simulation = self.surplus[x*365*24:(x+1)*365*24]                        for g in self.model.GenIndex:                            gen_power_simulation[g,:] = np.asarray(self.gen_list[g].power_out[x*365*24:(x+1)*365*24])/max(self.gen_list[g].power_out)                                #use instance surplus to limit fossil fuel power                limit = -self.fossilLimit * sum(surplus_instance * (surplus_instance < 0))                self.model.foss_lim_param = limit                                #fill in the correct parameters before running the model                for t in self.model.TimeIndex:                    self.model.Demand[t] = surplus_instance[t]                    for g in self.model.GenIndex:                        #print(gen_power_instance[g][t])                        self.model.NormalisedGen[g,t] = gen_power_instance[g,t]                                                             # Solve #                print('Finding Optimal System for ', self.YearRange[0], '-', self.YearRange[1], ', excluding', SimYears[y],'...')                start = time.time()                                opt.solve(self.model)                                  end = time.time()                print('Solved after: ',int(end - start), 's. Now causally simulating operation on this system for ', SimYears[y], ' ...')                            # Update System Characteristics #                                    for i in range(self.Mult_Stor.n_assets):                    self.Mult_Stor.assets[i].set_capacity(pyo.value(self.model.BuiltCapacity[i]))                                    for k in range(self.Mult_aggEV.n_assets):                    self.Mult_aggEV.assets[k].reset()                                    for b in range(2):                        self.Mult_aggEV.assets[k].chargertype[b] = pyo.value(self.model.EV_TypeBuiltCapacity[k,b])/self.Mult_aggEV.assets[k].number            # Simulate System Operation Causally #                                start = time.time()                #First Method is ordered Charging                #Find the input surplus:                input1 = surplus_simulation + sum(pyo.value(self.model.GenCapacity[g])*gen_power_simulation[g,:] for g in self.model.GenIndex)                #Simulate the system Causally                x1 = self.Mult_Stor.causal_system_operation(input1,c_order,d_order,self.Mult_aggEV,plot_timeseries = True,V2G_discharge_threshold = V2G_discharge_threshold)                Causal_Reliability.append((1-x1[0]/sum(surplus_simulation))*100)                b=0                for x in range(2*self.Mult_aggEV.n_assets):                    Causal_EV_Reliability[x].append(x1[1][b])                    b=1-b                                                        end = time.time()                print('Simulation Complete: ',int(end - start), 's. Now Non-Causally Simulating System Operation:')                                            # Simulate System Operation Non-Causally #                                #go through and constrain the generators to be zero (as their gen is captured within the input1 surplus already)                sim_gen_list = self.gen_list                for g in self.model.GenIndex:                    sim_gen_list[g].limits = [0.0,0.0]                                                    #constrain the storage and EVs to have their set value                sim_Mult_Stor = self.Mult_Stor                for i in range(sim_Mult_Stor.n_assets):                    sim_Mult_Stor.assets[i].limits = [pyo.value(self.model.BuiltCapacity[i]),pyo.value(self.model.BuiltCapacity[i])]                                    sim_Mult_aggEV = self.Mult_aggEV                for k in range(sim_Mult_aggEV.n_assets):                                for b in self.model.ChargeType:                        if b == 0 :                            sim_Mult_aggEV.assets[k].limits.append(pyo.value(self.model.EV_TypeBuiltCapacity[k,b]))                            sim_Mult_aggEV.assets[k].limits.append(pyo.value(self.model.EV_TypeBuiltCapacity[k,b]))                        elif b==1:                            sim_Mult_aggEV.assets[k].limits.append(pyo.value(self.model.EV_TypeBuiltCapacity[k,b]))                            sim_Mult_aggEV.assets[k].limits.append(pyo.value(self.model.EV_TypeBuiltCapacity[k,b]))                                #for the non causal operation want to remove constraint on fossil fuel use, but heavily cost it so the optimiser will operate the system at lowest carbon. The built capacities are also fixed!                if y==0:                    x2 = System_LinProg_Model(surplus = input1,fossilLimit = 10000.0, Mult_Stor = sim_Mult_Stor, Mult_aggEV = sim_Mult_aggEV, gen_list = sim_gen_list)                    x2.Form_Model(False,fossilfuelpenalty = 10000.0)                                   #update with correct gen data                    for t in x2.model.TimeIndex:                    x2.model.Demand[t] = input1[t]                                    opt.solve(x2.model)                                             Non_Causal_Reliability.append((1+sum(pyo.value(x2.model.Pfos[t])for t in x2.model.TimeIndex)/sum(surplus_simulation))*100) #The % of demand met by renewable power                                if y == 0:                    self.df_capital = opt_results_to_df(self.model)                else:                    self.df_capital = self.df_capital.append(opt_results_to_df(self.model))                                self.df_capital['Simulation Year'] = SimYears                    df = DataFrame({'Simulation Year': SimYears, 'Causal Reliability': Causal_Reliability})            for x in range(self.Mult_aggEV.n_assets):                df['Fleet '+str(x)+ ' V2G'] = Causal_EV_Reliability[x]                df['Fleet '+str(x) + ' Uni'] = Causal_EV_Reliability[x+1]                            df['Non Causal Reliability'] = Non_Causal_Reliability                                        return df                                                                                                                        